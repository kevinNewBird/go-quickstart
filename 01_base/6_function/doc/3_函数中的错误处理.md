# 1.说明
在java语言中，一个函数可能出错，try catch去捕获处理异常。<br/> 
而在go语言中，函数应该有一个返回值去告诉调用者是否成功，返回值不会不停的往上抛，取决于调用者是否处理（go设计者要求开发者必须要处理err，所以代码中会出现大量的if err != nil）。<br/>

# 2.分类
error， panic， recover。其中error是值，而panic和recover是函数。它们都是go语言中提供处理错误的方案。
## 2.1.error的使用
使用内置的模块errors进行定义。<br/>
示例如下：
```go
package main
import "errors"

func errorHandle() (int, error) {
	return 0, errors.New("this is an error")
}
```
## 2.2.panic的使用
是内置函数，其会导致程序退出（类似java中的System.exit()）。不推荐随便主动使用panic。<br/>
使用场景：一般在服务启动的过程中，必须有些依赖服务准备好，日志文件存在、mysql能连接通等， 这个时候才能启动服务，如果服务启动检查中发现了这些人和一个不满足那就调用panic<br/>
示例如下：
```go
package main

import "fmt"

func panicHandle() {
	// panic是个内置函数，其会导致程序退出
	panic("this is a panic")
	fmt.Println("this is a func")
}
```

## 2.3.recover的使用
没有panic的痛点。recover函数能捕获到panic，由开发者处理。recover只有在defer调用的函数中才会生效，即需要配合defer使用。<br/>
注意事项：
- 1.defer需要放在panic之前定义，且recover只有在defer调用的函数中才会生效
- 2.recover处理异常后，逻辑并不会恢复到panic的那个点去
- 3.多个defer会形成栈，后定义的defer会先执行

示例如下：
```go
// 3.recover
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("recover err:", r)
		}
	}()
	
	panicHandle() // 只是为了触发recover
```