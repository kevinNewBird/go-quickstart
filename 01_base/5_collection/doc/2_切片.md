# 1.切片的定义
切片和数组很相似，其底层是数组。相当于是动态数组，可根据实际情况自动扩缩容。<br/>
`var 变量名 []类型`

# 2.切片的初始化
初始化有三种方式：
- a.从数组直接创建
- b.使用[]type{..}, 比如[]string{"a","b","c"}
- c.make函数（性能较高）

# 3.切片的操作方法
- append： 添加单个或多个元素，以及两个同类型切片合并

```go
// 1.添加元素
var courses1 []string
courses1 = append(courses1, "go", "java")

// 2.合并两个切片
cousers2 := []string{"python", "c", "c++"}
// 这里省略号的目的是表示把切片打散，由go底层来完成
cousers2 = append(cousers2, courses1...)

cousers3 := []string{"python", "c", "c++"}
cousers3 = append(cousers3, courses1[1:]...)
// [python c c++ java], []string
fmt.Printf("%v, %T\n", cousers3, cousers3)
```

# 4.切片的元素访问
`sliceVar[start:end]`<br/>
说明：
- start：开始索引，闭区间。选填
- end： 结束索引，开区间。选填

注意：<br/>
- 如果只有start 没有end， 则表示从start开始 到 结尾 的所有数据
- 如果没有start 只有end， 则表示从头开始 到 end 的所有数据

# 5.如何删除和拷贝slice中的元素
- 删除：使用append+切片的访问完成对元素的删除。
- 拷贝：分为深拷贝和浅拷贝。深拷贝使用copy， 而浅拷贝使用:=进行赋值。

# 6.slice的原理剖析
go的sLice在函数参数传递的时候是值传递还是引用传递：值传递，效果又呈理出了引用的效果（不完全是）。

```go
package main

import (
	"fmt"
	"strconv"
)

func sliceParam(data []string) {
	data[0] = "java"
	for i := 0; i < 5; i++ {
		data = append(data, strconv.Itoa(i))
	}
}

func main() {
	courses := []string{"a", "b", "c"}
	sliceParam(courses)
	// [java b c] ： 0号元素修改生效，但是append添加并没有生效
	// 为什么？因为其是值传递，但是有具有引用传递的特征
	fmt.Println(courses)
}

```